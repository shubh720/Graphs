#include<iostream>
#include<algorithm>
using namespace std;

struct edge{
   int source;
   int dest;
   int weight; 
};

bool compare(edge e1,edge e2){
    return e1.weight < e2.weight;
}

int findparent(int v,int *parent){
  if(parent[v] == v){
      return v;
  }

 return findparent(parent[v],parent);
}

void union_find(edge* input,int e,int n){
 // sort acc to weight min-->to-->max
 sort(input,input+e,compare);

 // o/p array of n-1 size
  edge* output = new edge[n-1];
  int* parent = new int[n];  // n size q? bcoz vertice record
    
    // initially each element pointing itself
      for(int i=0;i<n;i++){
          parent[i] = i;
      }

int i=0;
int count=0;

  while(count != n-1){
    edge temp = input[i];

    int sourceParent = findparent(temp.source,parent);
    int destParent = findparent(temp.dest,parent);
  // sourceParent and destParent have top most parent
   if(sourceParent != destParent){
       // edge possible
      output[count] = temp;
      count++;
      parent[destParent] = sourceParent;  // my assumption 
   }
  // here means either same or added in both cases move
  i++;    
  }
  for(int i=0;i<n-1;i++){
     
     cout<< output[i].source <<" "<< output[i].dest <<" "<< output[i].weight<< endl;

  }

}

int main(){

 // enter total n,e
 int n,e;
 cin>>n>>e;

 edge* input = new edge[e];
   for(int i=0;i<e;i++){
       int s,d,w;
       cin>>s>>d>>w;
     input[i].source = s;
     input[i].dest = d;
     input[i].weight = w;  
   }

   union_find(input,e,n);


   return 0; 
}
